module LSL
  grammar SingleCommand
    include LSL::Quoting
    include LSL::List
    rule single_command
      ex spaced_after_ex:(ws after_ex)? {
        def args
          get_spaced_node(:after_ex).andand.args
        end
        def options
          get_spaced_node(:after_ex).andand.options
        end
        def command_hash
          LSL::Command::Single.new(:raw => text_value, :ex => ex.text_value, 
                               :args => args.andand.arg_values || [], :options => options.andand.hash_values || {})
        end
      }
    end
    rule after_ex
      spaced_args:(ws* args)? spaced_options:(ws* options)? {
        def args
          get_spaced_node(:args)
        end
        def options
          get_spaced_node(:options)
        end
        def command_hash
          LSL::Command::Single.new(:raw => text_value, :ex => LSL::Shell.instance.default_command, 
                               :args => args.andand.arg_values || [], :options => options.andand.hash_values || {})
        end
      }
    end
    
    rule ex
      word
    end
    
    rule arg
      comma_list
    end
    rule args
      arg spaced_args:(ws args)? {
        def arg_values
          [arg.unquotedx.to_parsed_obj] + (get_spaced_node(:args).andand.arg_values || [])
        end
      }
    end
    
    rule option_flag
      '-' 1..2 word
    end
    rule option
      option_flag spaced_option_value:(ws option_value:optionally_quoted_string)? {
        def kv
          {option_flag.word.text_value => get_spaced_node(:option_value).andand.unquotedx}
        end
      }
    end
    rule options
      option spaced_options:(ws options)? {
        def hash_values
          option.kv.merge(get_spaced_node(:options).andand.hash_values || {})
        end
      }
    end
  end
end